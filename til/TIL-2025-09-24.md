# TIL - 2025-09-24

## 오늘의 작업: HanaZoom 100명 부하테스트 완료 및 엔티티 기반 성능 최적화 전략 수립

### 🎯 한 줄 요약
HanaZoom의 100명 동시 로그인 부하테스트를 완료하고 성능 병목점을 분석한 결과, 데이터베이스 인덱스 부재와 설정 미최적화가 주요 원인임을 파악하여 엔티티 기반 인덱스 설정과 커넥션 풀 최적화 전략을 수립했다.

---

## 📊 부하테스트 결과 분석

### 1. 테스트 시나리오
- **테스트 대상**: 100명 동시 로그인 → 지역 정보 조회
- **테스트 도구**: Gatling 3.10.5
- **사용자 데이터**: 청라1동 실제 사용자 100명 (CSV 기반)
- **시뮬레이션**: HanaZoomChatSimulation.scala

### 2. 성능 지표
- **총 요청 수**: 200개 (로그인 100 + 지역조회 100)
- **성공률**: 100% (실패 0개) ✅
- **평균 응답 시간**: 1,035ms
- **최대 응답 시간**: 2,658ms
- **95% 응답 시간**: 2,309ms
- **처리량**: 40 req/sec

### 3. 주요 문제점
- **응답 시간이 1초로 느림** (목표: 500ms 미만)
- **95% 요청이 2.3초 초과** (타임아웃 위험)
- **처리량 부족** (100 req/sec 목표에 40 req/sec)
- **사용자 경험 저하** (체감상 매우 느림)

---

## 🔍 병목점 분석

### 1. 데이터베이스 쿼리 분석
```sql
-- 느린 쿼리 확인
EXPLAIN ANALYZE
SELECT m.*, r.name as region_name, r.full_name as full_region_name
FROM members m
LEFT JOIN regions r ON m.region_id = r.id
WHERE m.email = ?;
```

**문제점**:
- `members.email`에 인덱스 없음 → 풀 스캔
- `members.region_id`에 인덱스 없음 → 풀 스캔
- `regions.parent_id`에 인덱스 없음 → 풀 스캔
- N+1 쿼리 문제 가능성

### 2. 커넥션 풀 설정 분석
- **현재**: 기본 설정 (최대 10개 커넥션)
- **문제**: 100명 동시 요청 시 커넥션 부족
- **히카리 풀**: 타임아웃 및 리소스 경합

### 3. 애플리케이션 설정 분석
- **로그 레벨**: INFO (과도한 로깅)
- **배치 사이즈**: 기본값 (N+1 문제)
- **페치 전략**: 기본값 (불필요한 조인)

---

## 🚀 엔티티 기반 최적화 전략

### 1. Member 엔티티 인덱스 추가
```java
@Entity
@Table(name = "members", indexes = {
    @Index(name = "idx_members_email", columnList = "email", unique = true),
    @Index(name = "idx_members_region_id", columnList = "region_id"),
    @Index(name = "idx_members_email_region", columnList = "email, region_id"),
    @Index(name = "idx_members_status", columnList = "status")
})
public class Member {
    // ... 기존 코드
}
```

### 2. Region 엔티티 인덱스 추가
```java
@Entity
@Table(name = "regions", indexes = {
    @Index(name = "idx_regions_parent_id", columnList = "parent_id")
})
public class Region {
    // ... 기존 코드
}
```

### 3. 커넥션 풀 최적화 (application.yml)
```yaml
spring:
  datasource:
    hikari:
      maximum-pool-size: 50        # 10 → 50 (5배 증대)
      minimum-idle: 10
      idle-timeout: 300000         # 5분
      max-lifetime: 600000         # 10분
      connection-timeout: 20000    # 20초
```

### 4. JPA 설정 최적화
```yaml
spring:
  jpa:
    properties:
      hibernate:
        jdbc:
          batch_size: 25           # N+1 문제 해결
        order_inserts: true         # INSERT 최적화
        order_updates: true         # UPDATE 최적화
```

### 5. 로그 레벨 최적화
```yaml
logging:
  level:
    root: WARN                    # INFO → WARN
    org.hibernate.SQL: WARN       # INFO → WARN
    org.springframework.security: WARN
```

---

## 📈 예상 개선 효과

### Phase 1: 데이터베이스 최적화
- **응답 시간**: 1,035ms → 300ms (70% 개선)
- **95% 응답 시간**: 2,309ms → 500ms (78% 개선)
- **처리량**: 40 req/sec → 150 req/sec (275% 개선)
- **실패율**: 0% 유지

### Phase 2: 캐싱 및 비동기 처리
- **Redis 캐싱**: JWT 토큰 1시간, 사용자 정보 30분
- **@Async 활용**: 비동기 처리로 응답 시간 단축
- **예상 효과**: 80-90% 성능 개선

### Phase 3: 인프라 최적화
- **서버 스펙 업그레이드**: CPU/메모리 증설
- **데이터베이스 분리**: 읽기/쓰기 분리
- **모니터링 시스템**: Prometheus + Grafana

---

## 🧪 테스트 개선사항

### 1. Gatling 시뮬레이션 개선
```scala
// 사용자 카운터 추가로 디버깅 개선
var globalUserCounter = 0

// 로그인 요청 체크 강화
.check(jsonPath("$.data.accessToken").saveAs("jwtToken"))
.check(jsonPath("$.success").is("true"))
.check(jsonPath("$.data.accessToken").notNull)

// 지역 정보 조회 체크 강화
.check(jsonPath("$.data.regionId").notNull)
.check(jsonPath("$.data.roomName").notNull)
```

### 2. 로그 분석 도구 개발
- `logs/analyze_logs.py`: 로그 자동 분석
- `logs/performance_monitor.py`: 실시간 성능 모니터링
- HTML 보고서 생성으로 시각적 분석

---

## 🔧 기술적 인사이트

### 1. 엔티티 기반 인덱스 관리의 장점
- **코드와 DB 스키마 일치**: 버전 관리 용이
- **환경 간 일관성**: 모든 환경에서 동일 인덱스
- **마이그레이션 불필요**: 재시작만으로 적용
- **유지보수성**: 엔티티 수정으로 인덱스 관리

### 2. 성능 최적화 우선순위
1. **데이터베이스 인덱스** (가장 효과적, 70% 개선)
2. **커넥션 풀 증설** (병목점 해결, 50% 개선)
3. **캐싱 전략** (응답 속도 향상, 30% 개선)
4. **쿼리 최적화** (N+1 문제 해결, 20% 개선)

### 3. 모니터링 중요성
- **실시간 성능 추적**: 이상 징후 조기 발견
- **병목점 정밀 분석**: 정확한 최적화 방향 설정
- **개선 효과 검증**: 데이터 기반 의사결정

---

## 🎯 최종 목표 및 계획

### 목표 성능
- **응답 시간**: 500ms 미만
- **95% 응답 시간**: 1,000ms 미만
- **처리량**: 100 req/sec 이상
- **실패율**: 1% 미만

### 실행 계획
1. **즉시 (1-2일)**: 엔티티 인덱스 설정 및 커넥션 풀 최적화
2. **단기 (1주)**: Redis 캐싱 도입 및 비동기 처리 적용
3. **중기 (1개월)**: 인프라 업그레이드 및 모니터링 시스템 구축

### 성공 지표
- **사용자 만족도**: 90% 이상
- **서비스 안정성**: 99.9% uptime
- **확장성**: 1,000명 동시 접속 지원

---

## 💡 배운 점

### 1. 성능 최적화의 핵심
- **측정 없이는 최적화도 없다**: 테스트 없는 최적화는 사상누각
- **병목점 파악이 우선**: 모든 것을 최적화하려 하지 말고 핵심 병목점부터
- **단계적 접근**: 한 번에 모든 것을 바꾸지 말고 Phase별로 진행

### 2. 데이터베이스 최적화
- **인덱스는 선택이 아닌 필수**: 기본키 외에도 조회 조건에 인덱스 필수
- **쿼리 실행 계획 분석**: EXPLAIN ANALYZE로 실제 쿼리 성능 확인
- **커넥션 풀 관리**: 동시성 제어의 핵심

### 3. 테스트의 중요성
- **현실적인 시나리오**: 실제 사용자 데이터를 사용한 테스트
- **정확한 측정**: 응답 시간, 처리량, 에러율 등 다각적 측정
- **재현 가능한 테스트**: 동일한 조건에서 반복 가능한 테스트 환경

---

**100명 부하테스트를 통해 HanaZoom의 현재 성능 상태를 정확히 파악하고, 데이터 기반의 최적화 전략을 수립할 수 있었다. 특히 엔티티 기반 인덱스 관리의 중요성을 깨닫는 계기가 되었다.** 🚀
