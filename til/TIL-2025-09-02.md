# TIL 2025-09-02

## 🎯 오늘 구현한 것

### 1. Redis 연결 안정성 개선 및 웹소켓 에러 로그 최적화

- **문제**: Redis 연결이 끊어진 상태에서 웹소켓이 계속 데이터를 처리하려고 시도하면서 "LettuceConnectionFactory was destroyed" 에러가 미친듯이 발생하고 있었음.
- **해결**: `StockWebSocketHandler`에서 Redis 작업 전에 연결 상태를 확인하는 로직을 추가하고, 연결 실패 시 기본값을 사용하도록 수정하여 서비스 안정성을 크게 향상시킴.
- **적용**: Redis 연결 상태 확인 메서드(`isRedisConnectionAvailable`)를 모든 Redis 작업에 적용하고, 연결 실패 시에도 웹소켓 서비스가 정상 동작하도록 개선.

```java
// BE/HanaZoom/src/main/java/com/hanazoom/global/handler/StockWebSocketHandler.java
private String getStockNameFromCache(String stockCode) {
    try {
        // Redis 연결 상태 확인 후 조회
        if (isRedisConnectionAvailable()) {
            String cachedName = (String) redisTemplate.opsForValue().get("stock:name:" + stockCode);
            if (cachedName != null) {
                return cachedName;
            }
        } else {
            log.debug("Redis 연결 불가 - 캐시 조회 건너뛰기: {}", stockCode);
        }
        
        // DB에서 종목명 조회 후 Redis 연결 가능한 경우에만 캐시 저장
        // ... DB 조회 로직
    } catch (Exception e) {
        log.warn("⚠️ 종목명 조회 실패: {}", stockCode, e);
        return stockCode;
    }
}
```

### 2. 웹소켓 재연결 로직 개선

- **문제**: 웹소켓 재연결 시 Redis 연결 상태를 고려하지 않아 불필요한 재연결 시도가 반복됨.
- **해결**: 웹소켓 재연결 전에 Redis 연결 상태를 확인하고, Redis가 불안정한 경우 재연결을 지연하여 시스템 안정성을 향상시킴.
- **적용**: `handleKisSessionError`와 `afterConnectionClosed` 메서드에서 Redis 상태를 고려한 지능적인 재연결 로직 구현.

```java
// Redis 연결 상태 확인 후 재연결 결정
if (isRedisConnectionAvailable()) {
    scheduleReconnection();
} else {
    log.warn("⚠️ Redis 연결이 불안정하여 웹소켓 재연결을 지연합니다.");
    // Redis 연결이 불안정한 경우 더 긴 지연 후 재연결 시도
    new Thread(() -> {
        try {
            Thread.sleep(30000); // 30초 대기
            if (isRedisConnectionAvailable()) {
                connectToKis();
            }
        } catch (Exception e) {
            log.error("❌ 지연된 KIS WebSocket 재연결 실패", e);
        }
    }).start();
}
```

### 3. 프론트엔드 웹소켓 ping 기반 장 상태 동적 관리 시스템

- **문제**: 프론트엔드에서 서버의 장 열림/종료 상태를 실시간으로 파악할 수 없어 사용자가 현재 데이터의 상태를 명확히 알기 어려웠음.
- **해결**: `useStockWebSocket` 훅에 주기적 ping 전송과 데이터 수신 상태 추적 로직을 추가하여 장 열림/종료 상태를 동적으로 관리하는 시스템을 구현함.
- **적용**: 10초마다 서버에 ping을 보내고, 30초 동안 데이터가 없으면 자동으로 장 종료 상태로 변경하는 로직을 구현.

```typescript
// FE/hooks/useStockWebSocket.ts
interface WebSocketState {
  connected: boolean;
  connecting: boolean;
  error: string | null;
  stockData: Map<string, StockPriceData>;
  lastUpdate: number;
  lastDataReceived: number;    // 새로 추가
  isMarketOpen: boolean;       // 새로 추가
  pingInterval: number;        // 새로 추가
}

// 데이터 수신 상태 추적 및 장 열림/종료 상태 결정
const updateDataReceivedStatus = useCallback(() => {
  const now = Date.now();
  setState((prev) => ({
    ...prev,
    lastDataReceived: now,
  }));

  // 데이터 수신 타임아웃 설정 (30초)
  if (dataTimeoutRef.current) {
    clearTimeout(dataTimeoutRef.current);
  }
  
  dataTimeoutRef.current = setTimeout(() => {
    setState((prev) => ({
      ...prev,
      isMarketOpen: false,
    }));
  }, 30000); // 30초 동안 데이터가 없으면 장 종료로 간주
}, []);
```

### 4. Stock Ticker 컴포넌트 동적 상태 표시 시스템

- **문제**: 기존 티커는 단순히 연결/비연결 상태만 표시하여 사용자가 현재 장 상태를 파악하기 어려웠음.
- **해결**: 연결 상태와 장 열림/종료 상태를 조합한 동적 UI 시스템을 구현하여 실시간으로 상태를 반영하도록 개선.
- **적용**: 상태에 따른 색상 코딩과 아이콘 애니메이션을 추가하여 직관적인 상태 표시를 제공.

```typescript
// FE/components/stock-ticker.tsx
const getConnectionStatus = () => {
  if (!wsConnected) {
    return { status: 'disconnected', bgColor: 'from-red-600 via-red-500 to-red-600', icon: WifiOff, text: '연결이 끊어졌습니다. 재연결 중...' };
  }
  
  if (wsConnected && !isMarketOpen) {
    return { status: 'market-closed', bgColor: 'from-yellow-600 via-yellow-500 to-yellow-600', icon: WifiOff, text: '장종료' };
  }
  
  if (wsConnected && isMarketOpen) {
    return { status: 'market-open', bgColor: 'from-green-600 via-emerald-600 to-green-600', icon: Wifi, text: '장 열림' };
  }
  
  return { status: 'loading', bgColor: 'from-yellow-600 via-yellow-500 to-yellow-600', icon: Wifi, text: '주식 데이터 로딩 중...' };
};
```

### 5. 로그 레벨 최적화

- **문제**: Redis 연결 실패 관련 로그가 WARN 레벨로 설정되어 일반적인 연결 불안정 상황에서도 과도한 로그가 발생함.
- **해결**: Redis 연결 실패 관련 로그를 DEBUG 레벨로 변경하여 로그 스팸을 방지하고, 실제 문제 상황에서만 중요한 로그가 표시되도록 개선.

## 🧠 오늘의 학습

### 핵심 깨달음

> **"시스템의 안정성은 개별 컴포넌트의 완벽함보다는, 각 컴포넌트 간의 상호 의존성을 고려한 전체적인 설계에서 나온다."**

### 기술적 포인트

- **Redis 연결 관리**: Redis 연결이 불안정한 환경에서도 서비스가 정상 동작하도록 하는 방어적 프로그래밍의 중요성. 연결 상태 확인 후 작업 수행하는 패턴이 핵심.
- **웹소켓 상태 관리**: 단순한 연결/비연결 상태가 아닌, 데이터 수신 상태를 기반으로 한 동적 상태 관리가 사용자 경험을 크게 향상시킴.
- **프론트엔드 상태 동기화**: 백엔드의 복잡한 상태를 프론트엔드에서 직관적으로 표현하기 위한 상태 매핑과 UI 설계의 중요성.
- **로그 관리**: 운영 환경에서 로그 레벨 관리가 시스템 모니터링과 디버깅에 미치는 영향의 중요성.

## 🚀 내일 할 것

1. **웹소켓 연결 품질 모니터링**: ping 응답 시간과 데이터 수신 간격을 추적하여 연결 품질 지표를 제공하는 모니터링 시스템 구현
2. **Redis 연결 풀 최적화**: Redis 연결 풀 설정을 조정하여 연결 안정성을 더욱 향상시키고, 연결 실패 시 자동 복구 로직 강화
3. **사용자 알림 시스템**: 장 열림/종료 상태 변경 시 사용자에게 알림을 제공하는 시스템 구현

## 📊 웹소켓 안정성 개선 로드맵

```
Phase 1 (완료): 🛡️ Redis 연결 안정성 + 에러 로그 최적화
Phase 2 (완료): 🔄 동적 장 상태 관리 + ping 기반 상태 추적
Phase 3 (진행중): 📊 연결 품질 모니터링 + 사용자 알림
Phase 4 (계획): 🚨 장애 감지 + 자동 복구 시스템
Phase 5 (계획): 📈 성능 메트릭 + 대시보드
```

---

**Today's Key Insight**: 시스템의 복잡성은 개별 컴포넌트의 복잡성에서 오는 것이 아니라, 컴포넌트 간의 상호작용에서 발생한다. 따라서 전체적인 관점에서의 설계와 방어적 프로그래밍이 안정적인 시스템의 핵심이다.
