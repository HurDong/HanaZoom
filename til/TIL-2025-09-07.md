# TIL - 2025-09-07

## 오늘의 작업: WebRTC 1:1 화상통화 시스템 완성

### 🎯 주요 성과

- **WebRTC 1:1 화상통화 시스템 완전 구현**
- **역할 기반 Offer/Answer 분리로 안정적인 연결 보장**
- **ICE Candidate 처리 순서 문제 해결**
- **WebSocket 연결 안정화 및 오류 처리 개선**

---

## 🔧 해결한 주요 문제들

### 1. WebSocket 연결 즉시 끊김 문제

**문제**: WebSocket 연결 후 Offer 전송 직후 DISCONNECT 발생
**원인**: useEffect 의존성 배열이 불안정해서 렌더링마다 훅이 재실행
**해결**:

```typescript
// ❌ 문제가 있던 코드
const disconnect = useCallback(() => {
  // ...
}, [localStream]); // localStream 변경시마다 재생성

// ✅ 수정된 코드
const disconnect = useCallback(() => {
  setLocalStream((prevStream) => {
    if (prevStream) {
      prevStream.getTracks().forEach((track) => track.stop());
    }
    return null;
  });
  // ...
}, []); // 의존성 제거
```

### 2. WebRTC 상태 충돌 문제

**문제**: `setRemoteDescription` 오류 - "Called in wrong state: stable"
**원인**: 동일한 사용자가 Offer와 Answer를 모두 처리하려고 시도
**해결**: 역할 기반 분리

```typescript
// PB 역할: Offer 생성 → Answer 수신
if (userType === "pb") {
  const offer = await peerConnectionRef.current.createOffer();
  await peerConnectionRef.current.setLocalDescription(offer);
  sendOffer(offer);
}

// 고객 역할: Offer 수신 → Answer 생성
if (userType === "guest") {
  await peerConnectionRef.current.setRemoteDescription(offer);
  const answer = await peerConnectionRef.current.createAnswer();
  await peerConnectionRef.current.setLocalDescription(answer);
  sendAnswer(answer);
}
```

### 3. ICE Candidate 처리 순서 문제

**문제**: `addIceCandidate` 오류 - "The remote description was null"
**원인**: ICE Candidate가 remoteDescription 설정 전에 도착
**해결**: 큐 시스템 구현

```typescript
const handleIceCandidate = useCallback(
  async (candidate) => {
    if (!peerConnectionRef.current.remoteDescription) {
      // 큐에 저장
      if (!peerConnectionRef.current.pendingIceCandidates) {
        peerConnectionRef.current.pendingIceCandidates = [];
      }
      peerConnectionRef.current.pendingIceCandidates.push(candidate);
      return;
    }

    await peerConnectionRef.current.addIceCandidate(candidate);
  },
  [onError]
);

// setRemoteDescription 후 큐 처리
if (peerConnectionRef.current.pendingIceCandidates) {
  for (const candidate of peerConnectionRef.current.pendingIceCandidates) {
    await peerConnectionRef.current.addIceCandidate(candidate);
  }
  peerConnectionRef.current.pendingIceCandidates = [];
}
```

---

## 🏗️ 아키텍처 개선사항

### 1. 역할 기반 WebRTC 시스템

```typescript
interface UsePbRoomWebRTCProps {
  roomId: string;
  accessToken: string | null;
  userType?: string; // 'pb' | 'guest'
  onError?: (error: Error) => void;
  onRemoteStream?: (stream: MediaStream) => void;
}
```

### 2. 안정적인 WebSocket 연결 관리

- **중복 연결 방지**: `stompClientRef.current?.connected` 체크
- **의존성 최적화**: 불필요한 재실행 방지
- **오류 처리**: 연결 실패 시 오프라인 모드 전환

### 3. ICE Candidate 큐 시스템

- **순서 보장**: remoteDescription 설정 후 처리
- **안전한 추가**: 오류 처리 및 로깅
- **메모리 관리**: 처리 후 큐 초기화

---

## 📊 최종 동작 흐름

### PB (userType="pb")

1. WebSocket 연결
2. 미디어 스트림 요청
3. **Offer 생성 및 전송**
4. Answer 수신 및 처리
5. ICE Candidate 교환
6. 화상통화 연결 완료

### 고객 (userType="guest")

1. WebSocket 연결
2. 미디어 스트림 요청
3. **Answer 대기**
4. Offer 수신 → Answer 생성 및 전송
5. ICE Candidate 교환
6. 화상통화 연결 완료

---

## 🎉 성과 요약

### ✅ 완성된 기능

- **1:1 화상통화**: PB ↔ 고객 실시간 비디오 통화
- **역할 분리**: 명확한 Offer/Answer 역할 분담
- **안정적 연결**: WebSocket + WebRTC 안정화
- **오류 처리**: 모든 주요 오류 케이스 대응

### 🔧 기술적 개선

- **useEffect 최적화**: 의존성 배열 안정화
- **메모리 관리**: 적절한 cleanup 및 ref 사용
- **상태 관리**: WebRTC 상태 머신 준수
- **로깅 시스템**: 디버깅을 위한 상세 로그

### 📈 사용자 경험

- **직관적 역할**: PB가 상담을 주도하는 자연스러운 흐름
- **안정적 연결**: 끊김 없는 화상통화
- **빠른 연결**: 최적화된 시그널링 과정

---

## 🚀 다음 단계

1. **다중 참여자 지원**: 1:N 화상통화 확장
2. **화면 공유**: 데스크톱/화면 공유 기능
3. **녹화 기능**: 상담 내용 녹화 및 저장
4. **모바일 최적화**: 반응형 디자인 개선

---

## 💡 핵심 학습 포인트

1. **WebRTC 상태 머신 이해**: Offer/Answer 순서의 중요성
2. **React Hook 최적화**: 의존성 배열과 성능의 관계
3. **비동기 처리**: ICE Candidate 순서 보장의 필요성
4. **역할 기반 설계**: 명확한 책임 분리로 안정성 확보

**결과**: 완전히 작동하는 1:1 화상통화 시스템 완성! 🎥✨
