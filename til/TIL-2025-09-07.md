# TIL - 2025-09-07

## 오늘의 작업: WebRTC 1:1 화상통화 시스템 완성

### 🎯 주요 성과

- **WebRTC 1:1 화상통화 시스템 완전 구현**
- **역할 기반 Offer/Answer 분리로 안정적인 연결 보장**
- **ICE Candidate 처리 순서 문제 해결**
- **WebSocket 연결 안정화 및 오류 처리 개선**

---

## 🔧 해결한 주요 문제들

### 1. WebSocket 연결 즉시 끊김 문제

**문제**: WebSocket 연결 후 Offer 전송 직후 DISCONNECT 발생
**원인**: useEffect 의존성 배열이 불안정해서 렌더링마다 훅이 재실행
**해결**:

```typescript
// ❌ 문제가 있던 코드
const disconnect = useCallback(() => {
  // ...
}, [localStream]); // localStream 변경시마다 재생성

// ✅ 수정된 코드
const disconnect = useCallback(() => {
  setLocalStream((prevStream) => {
    if (prevStream) {
      prevStream.getTracks().forEach((track) => track.stop());
    }
    return null;
  });
  // ...
}, []); // 의존성 제거
```

### 2. WebRTC 상태 충돌 문제

**문제**: `setRemoteDescription` 오류 - "Called in wrong state: stable"
**원인**: 동일한 사용자가 Offer와 Answer를 모두 처리하려고 시도
**해결**: 역할 기반 분리

```typescript
// PB 역할: Offer 생성 → Answer 수신
if (userType === "pb") {
  const offer = await peerConnectionRef.current.createOffer();
  await peerConnectionRef.current.setLocalDescription(offer);
  sendOffer(offer);
}

// 고객 역할: Offer 수신 → Answer 생성
if (userType === "guest") {
  await peerConnectionRef.current.setRemoteDescription(offer);
  const answer = await peerConnectionRef.current.createAnswer();
  await peerConnectionRef.current.setLocalDescription(answer);
  sendAnswer(answer);
}
```

### 3. ICE Candidate 처리 순서 문제

**문제**: `addIceCandidate` 오류 - "The remote description was null"
**원인**: ICE Candidate가 remoteDescription 설정 전에 도착
**해결**: 큐 시스템 구현

```typescript
const handleIceCandidate = useCallback(
  async (candidate) => {
    if (!peerConnectionRef.current.remoteDescription) {
      // 큐에 저장
      if (!peerConnectionRef.current.pendingIceCandidates) {
        peerConnectionRef.current.pendingIceCandidates = [];
      }
      peerConnectionRef.current.pendingIceCandidates.push(candidate);
      return;
    }

    await peerConnectionRef.current.addIceCandidate(candidate);
  },
  [onError]
);

// setRemoteDescription 후 큐 처리
if (peerConnectionRef.current.pendingIceCandidates) {
  for (const candidate of peerConnectionRef.current.pendingIceCandidates) {
    await peerConnectionRef.current.addIceCandidate(candidate);
  }
  peerConnectionRef.current.pendingIceCandidates = [];
}
```

---

## 🏗️ 아키텍처 개선사항

### 1. 역할 기반 WebRTC 시스템

```typescript
interface UsePbRoomWebRTCProps {
  roomId: string;
  accessToken: string | null;
  userType?: string; // 'pb' | 'guest'
  onError?: (error: Error) => void;
  onRemoteStream?: (stream: MediaStream) => void;
}
```

### 2. 안정적인 WebSocket 연결 관리

- **중복 연결 방지**: `stompClientRef.current?.connected` 체크
- **의존성 최적화**: 불필요한 재실행 방지
- **오류 처리**: 연결 실패 시 오프라인 모드 전환

### 3. ICE Candidate 큐 시스템

- **순서 보장**: remoteDescription 설정 후 처리
- **안전한 추가**: 오류 처리 및 로깅
- **메모리 관리**: 처리 후 큐 초기화

---

## 📊 최종 동작 흐름

### PB (userType="pb")

1. WebSocket 연결
2. 미디어 스트림 요청
3. **Offer 생성 및 전송**
4. Answer 수신 및 처리
5. ICE Candidate 교환
6. 화상통화 연결 완료

### 고객 (userType="guest")

1. WebSocket 연결
2. 미디어 스트림 요청
3. **Answer 대기**
4. Offer 수신 → Answer 생성 및 전송
5. ICE Candidate 교환
6. 화상통화 연결 완료

---

## 🎉 성과 요약

### ✅ 완성된 기능

- **1:1 화상통화**: PB ↔ 고객 실시간 비디오 통화
- **역할 분리**: 명확한 Offer/Answer 역할 분담
- **안정적 연결**: WebSocket + WebRTC 안정화
- **오류 처리**: 모든 주요 오류 케이스 대응

### 🔧 기술적 개선

- **useEffect 최적화**: 의존성 배열 안정화
- **메모리 관리**: 적절한 cleanup 및 ref 사용
- **상태 관리**: WebRTC 상태 머신 준수
- **로깅 시스템**: 디버깅을 위한 상세 로그

### 📈 사용자 경험

- **직관적 역할**: PB가 상담을 주도하는 자연스러운 흐름
- **안정적 연결**: 끊김 없는 화상통화
- **빠른 연결**: 최적화된 시그널링 과정

---

## 🚀 다음 단계

1. **다중 참여자 지원**: 1:N 화상통화 확장
2. **화면 공유**: 데스크톱/화면 공유 기능
3. **녹화 기능**: 상담 내용 녹화 및 저장
4. **모바일 최적화**: 반응형 디자인 개선

---

## 💡 핵심 학습 포인트

1. **WebRTC 상태 머신 이해**: Offer/Answer 순서의 중요성
2. **React Hook 최적화**: 의존성 배열과 성능의 관계
3. **비동기 처리**: ICE Candidate 순서 보장의 필요성
4. **역할 기반 설계**: 명확한 책임 분리로 안정성 확보

**결과**: 완전히 작동하는 1:1 화상통화 시스템 완성! 🎥✨

---

## 🔧 핵심 기술적 문제 해결

### 🎯 주요 기술적 성과

- **Zustand 토큰 동기화 문제**: 스토어 상태 불일치 해결
- **데이터베이스 제약 조건 오류**: `joined_at` null 오류 해결
- **참여자 재입장 로직**: "이미 참여 중" 오류 해결
- **실시간 채팅 서비스**: WebSocket 기반 메시징 시스템 구현
- **동적 사용자 정보**: 하드코딩된 PB 이름을 API 연동으로 교체

---

## 🔧 추가로 해결한 문제들

### 4. Zustand 토큰 동기화 문제 (가장 중요한 해결)

**문제**: Zustand 스토어에 토큰이 있는데 컴포넌트에서 "없음"으로 인식
**증상**:

```
🔍 Zustand 스토어 상태: {accessToken: '있음', user: '있음', hasUser: true, userId: '94a23767-4cbd-4e51-af28-f9e37fb1756d'}
🚫 고객 입장 시 로그인 필요 - 로그인 페이지로 리다이렉트
```

**원인**: `useAuthStore()` 훅이 스토어 상태 변경을 제대로 감지하지 못함
**해결**: 직접 스토어 접근 방식으로 변경

```typescript
// ❌ 문제가 있던 코드
const { accessToken } = useAuthStore();
console.log("accessToken:", accessToken ? "있음" : "없음"); // "없음"

// ✅ 수정된 코드 - 핵심 해결책
const currentToken = useAuthStore.getState().accessToken;
console.log("accessToken:", currentToken ? "있음" : "없음"); // "있음"

// 모든 토큰 사용 부분을 이 방식으로 변경
const handleGuestJoin = useCallback(async () => {
  const currentToken = useAuthStore.getState().accessToken; // 직접 접근
  if (currentToken) {
    headers.Authorization = `Bearer ${currentToken}`;
  }
}, [consultationId]);
```

### 5. 데이터베이스 제약 조건 오류

**문제**: `Column 'joined_at' cannot be null` 오류
**증상**:

```
SQL Error: 1048, SQLState: 23000 Column 'joined_at' cannot be null
org.springframework.dao.DataIntegrityViolationException: could not execute statement
```

**원인**: `PbRoomParticipant` 생성 시 `joinedAt` 필드가 설정되지 않음
**해결**: 명시적 생성자 호출

```java
// ❌ 문제가 있던 코드
PbRoomParticipant participant = PbRoomParticipant.builder().build(); // joinedAt이 null

// ✅ 수정된 코드 - 핵심 해결책
PbRoomParticipant participant = new PbRoomParticipant(
    room,
    member,
    PbRoomParticipant.Role.valueOf(role.toUpperCase()),
    UUID.randomUUID().toString() // 이 생성자가 joinedAt = LocalDateTime.now() 설정
);

return participantRepository.save(participant);
```

### 6. 참여자 재입장 로직

**문제**: "이미 참여 중입니다" 오류로 재입장 불가
**증상**:

```
java.lang.IllegalStateException: 이미 참여 중입니다
```

**원인**: 동일한 사용자가 이미 활성 참여자인데 새로 추가하려고 시도
**해결**: 기존 참여자 확인 후 반환

```java
// ✅ 기존 참여자 확인 로직 - 핵심 해결책
Optional<PbRoomParticipant> existingParticipant =
    participantRepository.findByRoomIdAndMemberIdAndIsActiveTrue(roomId, memberId);

if (existingParticipant.isPresent()) {
    log.info("기존 참여자 반환: {}", existingParticipant.get().getId());
    return existingParticipant.get(); // 새로 생성하지 않고 기존 것 반환
}

// 기존 참여자가 없을 때만 새로 생성
PbRoomParticipant participant = new PbRoomParticipant(/* ... */);
return participantRepository.save(participant);
```

### 7. 실시간 채팅 서비스 구현

**문제**: 화상통화 중 실시간 채팅 기능 부재
**해결**: WebSocket 기반 채팅 시스템

```typescript
// ✅ 채팅 WebSocket 연결
const connectChatWebSocket = () => {
  const client = new Client({
    brokerURL: "ws://localhost:8080/ws/pb-room",
    connectHeaders: {
      Authorization: `Bearer ${currentToken}`, // 위에서 해결한 토큰 문제 적용
    },
  });

  client.onConnect = () => {
    client.subscribe(`/topic/pb-room/${consultationId}/chat`, (message) => {
      const chatMessage = JSON.parse(message.body);
      setChatMessages((prev) => [...prev, chatMessage]);
    });
  };
};
```

```java
// ✅ 백엔드 채팅 메시지 처리
@MessageMapping("/chat/{roomId}/send")
public void handleChatMessage(@DestinationVariable String roomId, ChatMessage message) {
    messagingTemplate.convertAndSend("/topic/pb-room/" + roomId + "/chat", message);
}
```

---

## 🏗️ 핵심 기술적 개선사항

### 1. Zustand 스토어 접근 패턴 개선

**문제**: React 훅의 상태 동기화 한계
**해결**: 직접 스토어 접근 패턴 도입

```typescript
// ✅ 모든 토큰 사용 부분에 적용된 패턴
const getCurrentToken = () => useAuthStore.getState().accessToken;

// WebRTC 연결
const connectWebSocket = () => {
  const token = getCurrentToken();
  if (token) {
    // WebSocket 연결 로직
  }
};

// API 호출
const handleGuestJoin = async () => {
  const token = getCurrentToken();
  const headers = token ? { Authorization: `Bearer ${token}` } : {};
  // API 호출 로직
};
```

### 2. 데이터베이스 트랜잭션 안정성

**문제**: JPA 엔티티 생성 시 필수 필드 누락
**해결**: 명시적 생성자 사용으로 데이터 무결성 보장

```java
// ✅ 안전한 엔티티 생성 패턴
public PbRoomParticipant createParticipant(String roomId, String memberId, String role) {
    // 기존 참여자 확인
    Optional<PbRoomParticipant> existing = findExistingParticipant(roomId, memberId);
    if (existing.isPresent()) {
        return existing.get();
    }

    // 새 참여자 생성 (모든 필수 필드 포함)
    return new PbRoomParticipant(room, member, role, UUID.randomUUID().toString());
}
```

---

## 📊 최종 시스템 구성

### 프론트엔드 (Next.js + TypeScript)

- **화상통화**: WebRTC 1:1 연결
- **실시간 채팅**: STOMP WebSocket
- **상태 관리**: Zustand + localStorage
- **UI/UX**: TailwindCSS + 반응형 디자인

### 백엔드 (Spring Boot)

- **WebRTC 시그널링**: STOMP WebSocket
- **채팅 서비스**: STOMP 메시지 브로커
- **참여자 관리**: JPA + MySQL
- **인증**: JWT + Spring Security

### 데이터베이스

- **pb_room_participants**: 참여자 정보 (joined_at, left_at)
- **pb_rooms**: 상담방 정보
- **members**: 사용자 정보

---

## 🎉 핵심 기술적 성과 요약

### ✅ 해결된 주요 기술적 문제들

1. **Zustand 토큰 동기화**: `useAuthStore.getState()` 직접 접근으로 해결
2. **데이터베이스 제약 조건**: `joined_at` null 오류 → 명시적 생성자 사용
3. **참여자 재입장**: "이미 참여 중" 오류 → 기존 참여자 확인 로직
4. **WebRTC 연결 안정성**: Offer/Answer 역할 분리, ICE Candidate 큐
5. **실시간 채팅**: WebSocket 기반 STOMP 메시징 시스템

### 🔧 핵심 해결 방법

- **상태 관리**: React 훅 한계 → 직접 스토어 접근 패턴
- **데이터 무결성**: Builder 패턴 → 명시적 생성자 사용
- **비즈니스 로직**: 예외 발생 → 기존 데이터 확인 후 처리
- **비동기 처리**: 순서 문제 → 큐 시스템으로 해결
- **실시간 통신**: 단방향 → 양방향 WebSocket 메시징

### 📈 기술적 완성도

- **프론트엔드**: Next.js + TypeScript + Zustand + WebRTC
- **백엔드**: Spring Boot + JPA + STOMP WebSocket
- **데이터베이스**: MySQL + 제약 조건 준수
- **실시간 통신**: WebRTC + WebSocket 동시 지원

**결과**: 안정적이고 완전한 PB 상담 시스템 완성! 🎥💬✨
